
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Gallery Teleport with Voiceover</title>
  <style>
    html, body { margin: 0; overflow: hidden; height: 100%; font-family: "Arial", Arial, sans-serif; }
    #exitBtn {
      position: absolute;

      bottom: 25%;
      right:10%;
      z-index: 10;
      padding: 10px 15px;
      background: rgba(0,0,0,0.7);
      color: white;
      border: none;
      font-size: 24px;
      cursor: pointer;
      display: none;
      text-align: center;
    }
    #subtitleBox {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 10px 20px;
      border-radius: 0px;
      font-size: 18px;
      text-align: center;
      max-width: 90%;
      width:70%;
      z-index: 15;
      display: none;
      font-size:36px;
    }
    #audioControls {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 0px;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 20;
      width: calc(100% - 40px);
    }
    #seekBar {
      width: 100%;
    }
    #startBtn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-size: 24px;
      background: rgba(0,0,0,0.8);
      color: white;
      border: none;
      border-radius: 0px;
      cursor: pointer;
      z-index: 100;
    }
    #instructions {
      display: none;
      position: absolute;
      top: 10px;
      left:10px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 0px;
      align-items: center;
      gap: 10px;
      z-index: 20;
      color:white;
    }
    button {
      background: #444;
      color: white;
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 0px;
    }
    button:hover {
      background: #666;
    }
  </style>
</head>
<body>
  <button id="startBtn">▶ Start Experience<p style="font-size:.5em;">WARNING: This content contains flashing images or patterns that may trigger seizures in individuals with photosensitive epilepsy or other light-sensitive conditions. Viewer discretion is advised. </p></button>
  <button id="exitBtn">X</button>
  <div id="subtitleBox"></div>

  <!-- Custom audio controls -->
  <div id="audioControls">
    
    <button id="playPauseBtn">▶ Play</button>
    <button id="muteBtn">Mute</button>
    <input type="range" id="seekBar" value="0" min="0" max="100" step="0.1">
  </div>

  <div id="instructions">Click and drag to reframe the camera. <br><br>Click on artworks to zoom in.</div>
  <audio id="voiceover" preload="auto"></audio>
  
  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  
<!-- Post-processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>

    

  <script>
    /* -------------------------------
       🎤 AUDIO + SUBTITLES SYSTEM
    ------------------------------- */
    const audioElement = document.getElementById("voiceover");
    const subtitleBox = document.getElementById("subtitleBox");
    const playPauseBtn = document.getElementById("playPauseBtn");
    const muteBtn = document.getElementById("muteBtn");
    const seekBar = document.getElementById("seekBar");

    // 👉 Swap audio file here
    audioElement.src = "https://static.wixstatic.com/mp3/a2e228_383cc18955d047a2b9df8ec788c84f6e.mp3"; // Replace with your file

    // 👉 Subtitles format: { start, end, text }
    const subtitles = [
  { start: 0.179, end: 2.099, text: "The School of Media and Communication at" },
  { start: 2.119, end: 4.359, text: "the London College of Fashion is a vibrant" },
  { start: 4.38, end: 7.099, text: "and dedicated community. We believe in" },
  { start: 7.119, end: 8.999, text: "shaping the future of fashion media," },
  { start: 9.26, end: 11.56, text: "communication, and design for performance." },
  { start: 12.159, end: 14.18, text: "The three programs span a wide range of" },
  { start: 14.239, end: 17.139, text: "disciplines from fashion film photography," },
  { start: 17.5, end: 19.62, text: "creative direction, fashion media and" },
  { start: 19.699, end: 22.22, text: "criticism, fashion curation, costume" },
  { start: 22.279, end: 25.439, text: "design, hair and makeup, and prosthetics" },
  { start: 25.459, end: 27.339, text: "for performance amongst many others." },
  { start: 28.219, end: 30.38, text: "But it is this interrelationship and the" },
  { start: 30.439, end: 32.04, text: "potentials at the edges of those" },
  { start: 32.099, end: 34.559, text: "disciplines that really enable us to move" },
  { start: 34.639, end: 37.54, text: "forward and to change our industries. As a" },
  { start: 37.599, end: 39.54, text: "school, we champion the values of" },
  { start: 39.599, end: 41.74, text: "collaboration, openness, and" },
  { start: 41.819, end: 44.379, text: "communication. This enables us to build" },
  { start: 44.399, end: 46.279, text: "opportunities between communities and" },
  { start: 46.299, end: 47.02, text: "disciplines." },
  { start: 47.739, end: 50.279, text: "We cultivate rich networks and connections" },
  { start: 50.299, end: 52.679, text: "with industry practitioners to pioneer" },
  { start: 52.759, end: 55.299, text: "new ways of collaborating based on shared" },
  { start: 55.34, end: 57.9, text: "values of co-curation and knowledge" },
  { start: 57.959, end: 58.58, text: "exchange." },
  { start: 59.479, end: 61.579, text: "Our students gain access to our research" },
  { start: 61.639, end: 63.639, text: "centers which include the Digital" },
  { start: 63.719, end: 66.04, text: "Anthropology Lab, the Center for Fashion" },
  { start: 66.119, end: 68.819, text: "Curation, and a whole range of hubs and" },
  { start: 68.879, end: 70.999, text: "networks that really do enrich their" },
  { start: 71.059, end: 72.359, text: "learning and experience." },
  { start: 73.059, end: 75.459, text: "Core to our approach is an understanding" },
  { start: 75.5, end: 77.939, text: "that the body is a creative site, and this" },
  { start: 78.0, end: 79.659, text: "connects all of our disciplines." },
  { start: 80.279, end: 82.239, text: "We also share values of engagement," },
  { start: 82.58, end: 85.459, text: "innovation, and activism which continue to" },
  { start: 85.479, end: 87.939, text: "enable us to move forward and to think in" },
  { start: 88.0, end: 88.659, text: "new ways." },
  { start: 89.439, end: 91.239, text: "Our students and staff work across" },
  { start: 91.299, end: 93.519, text: "disciplines and platforms, and we seek to" },
  { start: 93.54, end: 96.199, text: "create meaningful experiences and generate" },
  { start: 96.22, end: 98.399, text: "creative solutions to critical issues of" },
  { start: 98.4, end: 98.999, text: "our time." },
  { start: 100.099, end: 102.18, text: "Fashion for us is much more than just" },
  { start: 102.239, end: 104.519, text: "clothes or images. It's actually about" },
  { start: 104.54, end: 106.779, text: "experiences, and it has the capability to" },
  { start: 106.839, end: 108.46, text: "change lives. Thank you." }
]
;

    // Play/Pause toggle
    playPauseBtn.addEventListener("click", () => {
      if (audioElement.paused) {
        audioElement.play();
        playPauseBtn.textContent = "⏸ Pause";
      } else {
        audioElement.pause();
        playPauseBtn.textContent = "▶ Play";
      }
    });

    // Mute toggle
    muteBtn.addEventListener("click", () => {
      audioElement.muted = !audioElement.muted;
      muteBtn.textContent = audioElement.muted ? "🔊" : "Mute";
    });

    // Update seek bar as audio plays
    audioElement.addEventListener("timeupdate", () => {
      seekBar.value = (audioElement.currentTime / audioElement.duration) * 100;

      // Subtitles sync
      const currentTime = audioElement.currentTime;
      const currentSubtitle = subtitles.find(s => currentTime >= s.start && currentTime <= s.end);
      if (currentSubtitle) {
        subtitleBox.style.display = "block";
        subtitleBox.textContent = currentSubtitle.text;
      } else {
        subtitleBox.style.display = "none";
      }
    });

    // Seeking
    seekBar.addEventListener("input", () => {
      audioElement.currentTime = (seekBar.value / 100) * audioElement.duration;
    });

    // Reset play button when audio ends
    audioElement.addEventListener("ended", () => {
      playPauseBtn.textContent = "▶ Play";
      subtitleBox.style.display = "none";
      seekBar.value = 0;
    });
    
    const startBtn = document.getElementById("startBtn");

// ✅ Disable auto-rotate until user clicks
//controls.autoRotate = false;
//controls.update();

// ✅ Hide audio controls until started
document.getElementById("audioControls").style.display = "none";
document.getElementById("instructions").style.display = "none";
    /*
startBtn.addEventListener("click", () => {
  // Start spinning
  //controls.autoRotate = true;

  // Start audio (must be triggered by user gesture)
  audioElement.play();
  playPauseBtn.textContent = "⏸ Pause";

  // Show audio controls
  document.getElementById("audioControls").style.display = "flex";

  // Hide start button
  startBtn.style.display = "none";
});
*/
    startBtn.addEventListener("click", async () => {
  // Resume context first
  if (audioCtx.state === "suspended") {
    await audioCtx.resume();
    console.log("AudioContext resumed");
  }

  // Unmute before play
  audioElement.muted = false;

  // Play audio
  try {
    await audioElement.play();
    playPauseBtn.textContent = "⏸ Pause";
  } catch (err) {
    console.error("Play failed:", err);
  }

  // Show audio controls
  document.getElementById("audioControls").style.display = "flex";
document.getElementById("instructions").style.display = "flex";
  // Hide start button
  startBtn.style.display = "none";
      // Play all screens
  screens.forEach(video => {
    video.muted = false; // unmute if needed
    video.play().catch(e => console.warn("Video play prevented:", e));
  });
      //make 3d stuff clickable
      experienceStarted = true;
});

    //this is needed for audio reactive to work
    audioElement.crossOrigin = "anonymous";
    
    //audio sync

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const audioSource = audioCtx.createMediaElementSource(audioElement);
const analyser = audioCtx.createAnalyser();
analyser.fftSize = 256;
const dataArray = new Uint8Array(analyser.frequencyBinCount);

// Connect nodes
audioSource.connect(analyser);
analyser.connect(audioCtx.destination);



    
    /* -------------------------------
       🎨 YOUR EXISTING THREE.JS CODE
    ------------------------------- */
let scene, camera, renderer, controls, composer;
let raycaster, mouse;
let targetPosition = null;
let targetLookAt = null;
let zooming = false;
const zoomSpeed = 0.05;
const podiums = [];
    const screens = []; // store all video elements
    let experienceStarted = false;

let savedCameraPosition = null;
let savedCameraTarget = null;

const originalPosition = new THREE.Vector3(0, 2, 8);
const originalTarget = new THREE.Vector3(0, 2, 0);
const clock = new THREE.Clock();
    
const emissiveMaterial = new THREE.ShaderMaterial({
  uniforms: {
    uColor: { value: new THREE.Color(0xffffff) }, // cyan glow
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 uColor;
    varying vec2 vUv;

    void main() {
      // Always outputs emissive color, ignores lighting
      gl_FragColor = vec4(uColor, 1.0);
    }
  `,
  transparent: false,
});
    
 const uniforms = {
  uTime: { value: 0 },
  uSpeed: { value: 1.5 },
  uFrequency: { value: 80.0 },
  uDistortion: { value: -0.003 },
   uAudio: { value: 0.0 } // audio-reactive uniform
};

// Material
const materialLine = new THREE.ShaderMaterial({
  uniforms,
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    uniform float uSpeed;
    uniform float uFrequency;
    uniform float uDistortion;
    uniform float uAudio;
    varying vec2 vUv;

    void main() {
      // Animate UVs along X axis
      float x = vUv.y * uFrequency + uTime * uSpeed + cos(vUv.x*0.0+uTime);

      // Distort Y with a sine wave for wavy streaks
      float y = vUv.x + sin(vUv.y * 5.0 + uTime) * uDistortion ;

      // Grid lines by taking fractional part
      float lineX = abs(sin(x * .31415 * 60.0));
      float lineY = abs(sin(y * 314.15 * 12.0 ));
      float lineX2 = abs(sin(x * .31415 * 2.0));

      // Combine X streaks and faint Y lines for grid effect
      float streaks = smoothstep(0.5, 1.0, lineX);
      float grid    = smoothstep(0.1, .2, lineY);
      float breaks = smoothstep(0.1,1.0,lineX2);

      // Mix streaks (bright laser lines) and faint grid
      vec3 color = mix(vec3(.0, 0., 0.0), vec3(.5, .5, .5), streaks);
      color -= grid * .99;
      color-=breaks*.5;

      gl_FragColor = vec4(color, 1.0);
    }
  `,
  side: THREE.DoubleSide,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});
    const uniformsA = {
  uTime: { value: 0 },
  uSpeed: { value: 1.5 },
  uFrequency: { value: 40.0 },
  uDistortion: { value: -0.003 },
   uAudio: { value: 0.0 } // audio-reactive uniform
};

// Material
const materialLineA = new THREE.ShaderMaterial({
  uniforms:uniformsA,
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    uniform float uSpeed;
    uniform float uFrequency;
    uniform float uDistortion;
    uniform float uAudio;
    varying vec2 vUv;

    void main() {
      // Animate UVs along X axis
      float x = vUv.y * uFrequency + uTime * uSpeed  + cos(vUv.x*(uAudio*100.0)*2.0+uTime)*uAudio*20.0;

      // Distort Y with a sine wave for wavy streaks
      float y = vUv.x + sin(vUv.y * 5.0 + uTime) * uDistortion ;

      // Grid lines by taking fractional part
      float lineX = abs(sin(x * .31415 * 2.0));
      float lineY = abs(sin(y * 314.15 * 4.0 ));

      // Combine X streaks and faint Y lines for grid effect
      float streaks = smoothstep(.9, 1.0, lineX);
      float grid    = smoothstep(0.5, .9, lineY);

      // Mix streaks (bright laser lines) and faint grid
      vec3 color = mix(vec3(0, 0., 0.0), vec3(1.0, 1.0, 1.0), streaks);
      color -= grid * .99;

      gl_FragColor = vec4(color, 1.0);
    }
  `,
  side: THREE.DoubleSide,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});
     const uniformsOuter = {
  uTime: { value: 0 },
  uSpeed: { value: 2.0 },
  uFrequency: { value: 1000.0 },
  uDistortion: { value: .002 }
};

const materialLineOuter = new THREE.ShaderMaterial({
  uniforms: uniformsOuter, // <-- pass uniforms here
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    uniform float uSpeed;
    uniform float uFrequency;
    uniform float uDistortion;
    varying vec2 vUv;

    void main() {
      // Animate UVs along X axis
      float x = vUv.y * uFrequency + uTime * uSpeed + cos(vUv.x*0.0*uTime);

      // Distort Y with a sine wave for wavy streaks
      float y = vUv.x + sin(vUv.y * 5.0 + uTime) * uDistortion;

      // Grid lines by taking fractional part
      float lineX = abs(sin(x * 0.31415 * 4.0));
      float lineY = abs(sin(y * 314.15 * 8.0));

      // Combine X streaks and faint Y lines
      float streaks = smoothstep(0.5, 1.0, lineX);
      float grid    = smoothstep(0.1, 0.1, lineY);

      // Mix streaks and faint grid
      vec3 color = mix(vec3(0.0), vec3(1.0), streaks);
      color -= grid * 0.99;

      gl_FragColor = vec4(color, 1.0);
    }
  `,
  side: THREE.DoubleSide,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

init();
animate();
//THREE.RectAreaLightUniformsLib.init();
    
    

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000);
  

  camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.copy(originalPosition);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.physicallyCorrectLights = true;
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.body.appendChild(renderer.domElement);
  

// POST-PROCESSING SETUP
       composer = new THREE.EffectComposer(renderer);
  composer.setSize(window.innerWidth, window.innerHeight);
  // render pass (base scene)
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);
  
  // bloom pass
const bloomPass = new THREE.UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    .2,  // strength
    0.1,  // radius
    0.85  // threshold
);
composer.addPass(bloomPass);
  




  
  //controls

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.copy(originalTarget);
  
  // ✅ Enable auto-rotate
  controls.autoRotate = true;         // turn on auto-rotation
  controls.autoRotateSpeed = .4;     // adjust rotation speed (positive = clockwise, negative = counter-clockwise)

  // ✅ Lock zoom level
  //const lockDistance = camera.position.distanceTo(originalTarget);
  //controls.minDistance = lockDistance;
  //controls.maxDistance = lockDistance;

  // disable zooming via scroll
  controls.enableZoom = false;
  
  controls.update();
  
  

  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
  
  

  // Lights
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(10, 10, 10);
  //light.castShadow = true;
  light.shadow.mapSize.width = 256;
  light.shadow.mapSize.height = 256;
  //scene.add(light);

  const ambient = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambient);

  const pointLight1 = new THREE.PointLight(0xffffff, 100, 100);
  pointLight1.position.set(0, 50, -3);
  pointLight1.shadow.mapSize.width = 4096;
  pointLight1.shadow.mapSize.height = 4096;
  pointLight1.castShadow = true;
  scene.add(pointLight1);
  
  const rectLight = new THREE.RectAreaLight( 0xffffff, 0,  10, 10 );
  rectLight.castShadow=true;
rectLight.position.set( 0, 100, 0 );
rectLight.lookAt( 0, 0, 0 );
  //scene.add( rectLight )
  
  

   


  // Floor
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(600, 600),
    new THREE.MeshStandardMaterial({ color: 0x070707 })
  );
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);
  
  //outersphere
  const outerSphere = new THREE.Mesh(
    new THREE.SphereGeometry( 100, 32, 16 )
  );
  outerSphere.material=materialLineOuter;
  outerSphere.position.y=1;
  
  scene.add(outerSphere);

  const roof = new THREE.Mesh(
    new THREE.CylinderGeometry(40, 40,1,64),
    new THREE.MeshStandardMaterial({ color: 0xcccccc })
  );
  roof.rotation.x = 0;//-Math.PI / 2;
  roof.position.y=50;
  roof.material = emissiveMaterial;
  scene.add(roof);
  // Podiums
  const colors = [0xff0000,0x00ff00,0x0000ff,0xffff00,0xff00ff,0x00ffff,0xff8800,0x8800ff];
  for (let i = 0; i < 0; i++) {
    const podium = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshStandardMaterial({ color: colors[i] })
    );
    let x, z, distance;
    do {
      const angle = Math.random() * Math.PI * 2;
      distance = 3 + Math.random() * 8;
      x = Math.cos(angle) * distance;
      z = Math.sin(angle) * distance;
    } while (distance < 2);
    podium.position.set(x, 0.5, z);
    podium.rotation.y = Math.random() * Math.PI * 2;
    podium.castShadow=true;
    scene.add(podium);
    podiums.push(podium);
  }

  // Load GLTF (keep original materials!)
  const loader = new THREE.GLTFLoader();
loader.load(
  //'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb'
  //'https://static.wixstatic.com/3d/a2e228_247044ddb9ca45c4aa950ba98b4e2993.glb'
  'https://static.wixstatic.com/3d/a2e228_9ac5269f6d664fc4aa1c82e4a1e8a8fc.glb',
  function (gltf) {
    const model = gltf.scene;
    model.position.set(0, 0, -3);
    model.scale.setScalar(2);

    model.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = false;
        child.receiveShadow = false;

        // 🔄 Replace material with a lit one
        const oldMat = child.material;
        child.material = new THREE.MeshStandardMaterial({
          map: oldMat.map || null,            // keep texture if it exists
          color: oldMat.color || new THREE.Color(0xffffff),
          metalness: 0.3,                     // tweak as needed
          roughness: 0.7,
        });
        child.material = materialLine;
      }
    });

    scene.add(model);
  }
);
  
  // Load GLTF (keep original materials!)
  const loader2 = new THREE.GLTFLoader();
loader2.load(
  //'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb'
  //'https://static.wixstatic.com/3d/a2e228_25896596c8f74a9fbadf063c00e6f466.glb'
  'https://static.wixstatic.com/3d/a2e228_9ac5269f6d664fc4aa1c82e4a1e8a8fc.glb',
  function (gltf) {
    const model = gltf.scene;
    model.position.set(0, 0, -3);
    model.scale.setScalar(2);

    model.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;

        // 🔄 Replace material with a lit one
        const oldMat = child.material;
        child.material = new THREE.MeshStandardMaterial({
          map: oldMat.map || null,            // keep texture if it exists
          color: oldMat.color || new THREE.Color(0xffffff),
          metalness: 0.3,                     // tweak as needed
          roughness: 0.7,
        });
        
      }
    });

    scene.add(model);
  }
);
  
  //3d models
  
  //logo
    addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_b95a1d6fdedd4df9bee1701ab00fa470.glb',
  position: new THREE.Vector3(0, 12, -20),
  rotation: Math.PI *2,
  scale: 1.5,
  plinthHeight: 0,
  plinthRadius: 0,
    objectOffsetHeight:0,
    objectOffsetRotation: 0,
      clickable:false,
      light_ :false,
      emissiveWhite:true
});
  
  //front 8
  addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_2b57df5830ae4be7b45a9e5b0439b05e.glb',
  position: new THREE.Vector3(0, 0, -14),
  rotation: Math.PI *2,
  scale: .25,
  plinthHeight: 1,
  plinthRadius: .8,
    objectOffsetHeight:0,
    objectOffsetRotation: 0.5
});
  
  //back right 33
    addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_76f2e3e3c91a4494b6404721a61a34d1.glb',
  position: new THREE.Vector3(10, 0, 10),
  rotation: Math.PI *1.25,
  scale: .22,
  plinthHeight: 1,
  plinthRadius: .8,
    objectOffsetHeight: 0,
      objectOffsetRotation: Math.PI
});



  //left 3
  
     addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_1532b0181efd484b8d87d6cabfffc3f9.glb',
  position: new THREE.Vector3(-10, 0, 6),
  rotation: Math.PI * 2.7,
  scale: .3,
  plinthHeight: 1,
  plinthRadius: .7,
    objectOffsetHeight: 0,
       objectOffsetRotation: 0
}); 
  
  //right 9
      addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_16f876eadfac4d149dd5fd1dc72480e1.glb',
  position: new THREE.Vector3(11, 0, -4),
  rotation: Math.PI*1.6,
  scale: .45,
  plinthHeight: 1,
  plinthRadius: .9,
    objectOffsetHeight: 0,
       objectOffsetRotation: 0
});
  
  // Place a 16:9 screen at (0,2,-5), rotated slightly
  //toms film
addScreen({
  url: "https://video.wixstatic.com/video/25b4fa_7e131bb1b6774460a81ea773e3b54edc/1080p/mp4/file.mp4",
  width: 25,
  height: 10,
  position: [30, 16,-5],
  rotation: [0, Math.PI*1.50, 0]
});
  //ual ffaward
  addScreen({
  url: "https://video.wixstatic.com/video/a2e228_fe5167c3632a45ef901aeeadd24d1489/720p/mp4/file.mp4",
  width: 25,
  height: 10,
  position: [45, 8,10],
  rotation: [0, Math.PI*1.37, 0]
});
  //beth fraiser
  addScreen({
  url: "https://video.wixstatic.com/video/bf8dab_38d3e799a4b34f8aa11cff81ebbd7105/1080p/mp4/file.mp4",
  width: 25,
  height: 14,
  position: [-30, 24,0],
  rotation: [0, Math.PI*0.50, 0]
});
  //behind screen
 /* addScreen({
  url: "https://video.wixstatic.com/video/25b4fa_5727856c53404310908a3443cba08b92/1080p/mp4/file.mp4",
  width: 12,
  height: 6.75,
  position: [0, 6,11],
  rotation: [0, Math.PI*1, 0]
});*/
  //long forward screen
   /* addScreen({
  url: "https://video.wixstatic.com/video/25b4fa_7e131bb1b6774460a81ea773e3b54edc/1080p/mp4/file.mp4",
  width: 12,
  height: 20,
  position: [0, 20,-31],
  rotation: [0, Math.PI*2, 0]
});*/
  
    //behind screen far
  addScreen({
  url: "https://video.wixstatic.com/video/25b4fa_5727856c53404310908a3443cba08b92/1080p/mp4/file.mp4",
  width: 18,
  height: 10,
  position: [-5, 24,37],
  rotation: [0, Math.PI*.95, 0]
});
  
  //ma photos
    addScreen({
  url: "https://static.wixstatic.com/media/a2e228_35e3fe1810774025bcff6fc1771a9828~mv2.jpg",
  width: 3,
  height: 4,
  position: [10, 3,-18],
  rotation: [0, Math.PI*1.8, 0],
          clickable:true,
          text:"Paige Lee Miller",
          fontSize:30
});
      addScreen({
  url: "https://static.wixstatic.com/media/a2e228_24efecce13e2479ba14108cab139ce1f~mv2.jpg",
  width: 3,
  height: 4,
  position: [13, 3,-15.5],
  rotation: [0, Math.PI*1.75, 0],
        text:"Andrea Brandt",
          clickable:true
});
      addScreen({
  url: "https://static.wixstatic.com/media/a2e228_bb25ca93634a40a4a7ec1036d87ef42f~mv2.jpg",
  width: 3,
  height: 4,
  position: [15, 3,-12],
  rotation: [0, Math.PI*1.65, 0],
          clickable:true,
          text:"Ana Margarita Flores",
          fontSize:30
});

  
  //ba photography
      addScreen({
  url: "https://static.wixstatic.com/media/a2e228_1002331e45c941c597edb9c7e7aada8c~mv2.jpg",
  width: 3,
  height: 4,
  position: [-15, 3,-2],
  rotation: [0, Math.PI*.5, 0],
        offsetClick:.7,
          clickable:true,
          text:"Ana Margarita Flores",
          fontSize:30
});
  


        addScreen({
  url: "https://static.wixstatic.com/media/a2e228_b4eb45cfdfd4487d9417a0f81826f07d~mv2.jpg",
  width: 3,
  height: 4,
  position: [-14, 3,-6],
  rotation: [0, Math.PI*.35, 0],
          offsetClick:.7,
          clickable:true,
          text:"Ana Margarita Flores",
          fontSize:30
          
});
        addScreen({
  url: "https://static.wixstatic.com/media/a2e228_fee41ee6c02c4d03a7ea96cb6403f5ce~mv2.jpg",
  width: 3,
  height: 4,
  position: [-11.5, 3,-9.5],
  rotation: [0, Math.PI*.225, 0],
          offsetClick:.7,
          clickable:true,
          text:"Jiayi Xu",
          fontSize:30
});
  
  


  
    // 3. Audio Mesh
    const geometry1 = new THREE.SphereGeometry(1.2, 1 , 1);


const streakMesh = new THREE.Mesh(geometry1, materialLineA);
 
streakMesh.position.set(0, 1.5, 0);
scene.add(streakMesh);
   //streakMesh.rotation.x = Math.PI / 4; 
//streakMesh.rotation.y = Math.PI / 4; 



      window.addEventListener('click', onMouseClick);
      window.addEventListener('resize', onWindowResize);

      document.getElementById('exitBtn').addEventListener('click', () => {
        zooming = false;
        targetPosition = null;
        targetLookAt = null;
        if (savedCameraPosition && savedCameraTarget) {
          camera.position.copy(savedCameraPosition);
          controls.target.copy(savedCameraTarget);
        } else {
          camera.position.copy(originalPosition);
          controls.target.copy(originalTarget);
        }
        controls.enabled = true;
        controls.update();
        document.getElementById('exitBtn').style.display = 'none';
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseClick(event) {
      if(experienceStarted==false)return;
      if (!controls.enabled) return;
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(podiums);
      if (intersects.length > 0) {
        savedCameraPosition = camera.position.clone();
        savedCameraTarget = controls.target.clone();
        const podium = intersects[0].object;
        const podiumPos = podium.position.clone();
        const frontDirection = new THREE.Vector3(0, 0, 1);
        frontDirection.applyEuler(podium.rotation);
        const cameraOffset = frontDirection.multiplyScalar(4);
        targetPosition = podiumPos.clone().add(cameraOffset);
        targetPosition.y = podiumPos.y + .5;
        targetLookAt = podiumPos.clone();
        targetLookAt.y += 0;
        zooming = true;
        controls.enabled = false;
        document.getElementById('exitBtn').style.display = 'block';
      }
    }
    
    
    function addScreen({ 
  url, 
  width = 4, 
  height = 2.25, 
  position = [0, 0, 0], 
  rotation = [0, 0, 0],
      offsetClick=0,
  clickable = false,
      text="",
      fontSize=30
}) {
  let texture;

  // Detect video vs image
  const isVideo = /\.(mp4|webm|ogg)$/i.test(url);

  if (isVideo) {
    const video = document.createElement('video');
    
    video.src = url;
    video.crossOrigin = "anonymous";
    video.loop = true;
    video.muted = true;
    video.playsInline = true;
    video.autoplay = true;
    video.play();
     screens.push(video); // store it for later

    texture = new THREE.VideoTexture(video);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.format = THREE.RGBFormat;
  } else {
    texture = new THREE.TextureLoader().load(url);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.format = THREE.RGBFormat;
  }

  // Material
  const material = new THREE.MeshBasicMaterial({
    map: texture,
    side: THREE.FrontSide,
    toneMapped: false
  });

  // Plane
  const geometry = new THREE.PlaneGeometry(width, height);
  const screenMesh = new THREE.Mesh(geometry, material);
  screenMesh.position.set(...position);
  screenMesh.rotation.set(...rotation);
  scene.add(screenMesh);

  // Clickable podium (optional)
  if (clickable) {
    const podium = new THREE.Mesh(
      new THREE.BoxGeometry(width, height, 1),
      new THREE.MeshBasicMaterial({ visible: false })
    );
    //let a = position-offsetClick;
    podium.position.set(position[0],position[1]-offsetClick,position[2]);
    podium.rotation.set(...rotation);
    scene.add(podium);
    podiums.push(podium);
  }
      
        const textMesh = makeTextPlane(text, { fontsize: fontSize, textColor: { r: 200, g: 255, b: 200 } });
textMesh.position.set(position[0],position[1]-(height/2)-.3,position[2]);
  textMesh.rotation.set(...rotation);
scene.add(textMesh);

  return screenMesh;
}


    function addModelOnPlinth({
  url,             // GLTF url
  position,        // THREE.Vector3
  rotation = 0,    // y-axis rotation in radians
  scale = 1,       // uniform scale
  plinthHeight = 1,
  plinthRadius = 0.7,
  objectOffsetHeight = 0.5,
  objectOffsetRotation = 0,
  clickable = true,
  light_ = true,
  emissiveWhite = false   // <-- NEW OPTION
}) {
  const group = new THREE.Group();
  group.position.copy(position);
  group.rotation.y = rotation;

  // Cylinder plinth
  const plinth = new THREE.Mesh(
    new THREE.CylinderGeometry(plinthRadius, plinthRadius, plinthHeight, 32),
    new THREE.MeshStandardMaterial({ color: 0x777777 })
  );
  plinth.position.y = plinthHeight / 2; // lift so bottom sits at ground
  plinth.castShadow = true;
  plinth.receiveShadow = true;
  group.add(plinth);

  // Load model
  const loader = new THREE.GLTFLoader();
  loader.load(url, (gltf) => {
    const model = gltf.scene;
    model.scale.setScalar(scale);

    // place on top of plinth
    model.position.y = plinthHeight + objectOffsetHeight;
    model.rotation.y = objectOffsetRotation;
    model.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = false;

        if (emissiveWhite) {
          // Force emissive white
          child.material = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            emissive: 0xffffff,
            emissiveIntensity: 1.5,
            metalness: 0,
            roughness: 0
          });
        } else {
          // Convert unlit/basic if needed
          if (child.material.type === "MeshBasicMaterial") {
            child.material = new THREE.MeshStandardMaterial({
              map: child.material.map || null,
              color: child.material.color || new THREE.Color(0xffffff),
              metalness: 0.3,
              roughness: 0.7
            });
          }
        }
      }
    });

    group.add(model);
  });

  scene.add(group);

  // Add click-to-move bounding box
  if (clickable) {
    const podium = new THREE.Mesh(new THREE.BoxGeometry(2, 4, 2));
    let x, z, distance;
    do {
      const angle = Math.random() * Math.PI * 2;
      distance = 3 + Math.random() * 8;
      x = Math.cos(angle) * distance;
      z = Math.sin(angle) * distance;
    } while (distance < 2);
    podium.position.set(position.x, position.y + 2, position.z);
    podium.rotation.y = rotation;
    podium.visible = false;
    scene.add(podium);
    podiums.push(podium);
  }

  if (light_) {
    const pointLight1 = new THREE.PointLight(0xffffff, 50, 12);
    pointLight1.rotation.y = rotation;
    pointLight1.position.set(position.x, position.y + 10, position.z);
    pointLight1.translateZ(2);
    pointLight1.castShadow = false;
    scene.add(pointLight1);
  }

  return group;
}
    
 function makeTextPlane(message, parameters = {}) {
  const fontface = parameters.fontface || "Arial";
  const fontsize = parameters.fontsize || 64;
  const textColor = parameters.textColor || { r: 255, g: 255, b: 255 };

  // create canvas
  const canvas = document.createElement('canvas');
  const context = canvas.getContext('2d');
  context.font = `${fontsize}px ${fontface}`;

  // adjust canvas size to fit text
  const textWidth = context.measureText(message).width;
  canvas.width = textWidth + 20;
  canvas.height = fontsize * 1.5;

  // redraw with proper resolution
  context.font = `${fontsize}px ${fontface}`;
  context.fillStyle = `rgb(${textColor.r},${textColor.g},${textColor.b})`;
  context.fillText(message, 10, fontsize);

  // canvas → texture
  const texture = new THREE.CanvasTexture(canvas);
  texture.needsUpdate = true;

  // make material
  const material = new THREE.MeshBasicMaterial({
    map: texture,
    transparent: true,
    side: THREE.DoubleSide
  });

  // plane geometry matches canvas ratio
  const geometry = new THREE.PlaneGeometry(canvas.width / 100, canvas.height / 100);
  const mesh = new THREE.Mesh(geometry, material);

  return mesh;
}

    
    // 4. Animate
function animateStreaks(delta) {
  materialLine.uniforms.uTime.value += delta;
  materialLineOuter.uniforms.uTime.value += delta;
  
  //Audio reactive stuff
  // Get average frequency from analyser
  analyser.getByteFrequencyData(dataArray);

  // Compute normalized audio value (0-1)
  let sum = 0;
  for (let i = 0; i < dataArray.length; i++) {
    sum += dataArray[i];
  }
  const avg = sum / dataArray.length;
  uniformsA.uAudio.value = avg / 255; // normalized
}


    function animate() {
      requestAnimationFrame(animate);
      if (zooming && targetPosition && targetLookAt) {
        camera.position.lerp(targetPosition, zoomSpeed);
        controls.target.lerp(targetLookAt, zoomSpeed);
        controls.update();
        if (camera.position.distanceTo(targetPosition) < 0.05) {
          zooming = false;
        }
      }
      const delta = clock.getDelta();
      animateStreaks(delta);
      controls.update();
      
      
      //renderer.render(scene, camera);
      // Render with post-processing
      composer.render();
    }
  </script>
</body>
</html>
