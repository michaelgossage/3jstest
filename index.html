
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Gallery Teleport with Voiceover</title>
  <style>
    html, body { margin: 0; overflow: hidden; height: 100%; }
    #exitBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      padding: 10px 15px;
      background: rgba(0,0,0,0.7);
      color: white;
      border: none;
      font-size: 16px;
      cursor: pointer;
      display: none;
    }
    #subtitleBox {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 10px 20px;
      border-radius: 10px;
      font-size: 18px;
      text-align: center;
      max-width: 80%;
      z-index: 15;
      display: none;
    }
    #audioControls {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 20;
      width: calc(100% - 40px);
    }
    #seekBar {
      width: 100%;
    }
    button {
      background: #444;
      color: white;
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 5px;
    }
    button:hover {
      background: #666;
    }
  </style>
</head>
<body>
  <button id="exitBtn">Exit</button>
  <div id="subtitleBox"></div>

  <!-- Custom audio controls -->
  <div id="audioControls">
    <button id="playPauseBtn">▶ Play</button>
    <button id="muteBtn">🔇 Mute</button>
    <input type="range" id="seekBar" value="0" min="0" max="100" step="0.1">
  </div>

  <audio id="voiceover" preload="auto"></audio>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    /* -------------------------------
       🎤 AUDIO + SUBTITLES SYSTEM
    ------------------------------- */
    const audioElement = document.getElementById("voiceover");
    const subtitleBox = document.getElementById("subtitleBox");
    const playPauseBtn = document.getElementById("playPauseBtn");
    const muteBtn = document.getElementById("muteBtn");
    const seekBar = document.getElementById("seekBar");

    // 👉 Swap audio file here
    audioElement.src = "https://static.wixstatic.com/mp3/a2e228_383cc18955d047a2b9df8ec788c84f6e.mp3"; // Replace with your file

    // 👉 Subtitles format: { start, end, text }
    const subtitles = [
      { start: 0, end: 4, text: "Welcome to the gallery." },
      { start: 4, end: 8, text: "Explore the glass structures around you." },
      { start: 8, end: 12, text: "Click on a podium to zoom in closer." },
      { start: 12, end: 20, text: "Press exit to return to the main view." }
    ];

    // Play/Pause toggle
    playPauseBtn.addEventListener("click", () => {
      if (audioElement.paused) {
        audioElement.play();
        playPauseBtn.textContent = "⏸ Pause";
      } else {
        audioElement.pause();
        playPauseBtn.textContent = "▶ Play";
      }
    });

    // Mute toggle
    muteBtn.addEventListener("click", () => {
      audioElement.muted = !audioElement.muted;
      muteBtn.textContent = audioElement.muted ? "🔊 Unmute" : "🔇 Mute";
    });

    // Update seek bar as audio plays
    audioElement.addEventListener("timeupdate", () => {
      seekBar.value = (audioElement.currentTime / audioElement.duration) * 100;

      // Subtitles sync
      const currentTime = audioElement.currentTime;
      const currentSubtitle = subtitles.find(s => currentTime >= s.start && currentTime <= s.end);
      if (currentSubtitle) {
        subtitleBox.style.display = "block";
        subtitleBox.textContent = currentSubtitle.text;
      } else {
        subtitleBox.style.display = "none";
      }
    });

    // Seeking
    seekBar.addEventListener("input", () => {
      audioElement.currentTime = (seekBar.value / 100) * audioElement.duration;
    });

    // Reset play button when audio ends
    audioElement.addEventListener("ended", () => {
      playPauseBtn.textContent = "▶ Play";
      subtitleBox.style.display = "none";
      seekBar.value = 0;
    });

    /* -------------------------------
       🎨 YOUR EXISTING THREE.JS CODE
    ------------------------------- */
let scene, camera, renderer, controls;
let raycaster, mouse;
let targetPosition = null;
let targetLookAt = null;
let zooming = false;
const zoomSpeed = 0.05;
const podiums = [];

let savedCameraPosition = null;
let savedCameraTarget = null;

const originalPosition = new THREE.Vector3(0, 2, 10);
const originalTarget = new THREE.Vector3(0, 2, 0);
const clock = new THREE.Clock();
    
const emissiveMaterial = new THREE.ShaderMaterial({
  uniforms: {
    uColor: { value: new THREE.Color(0xffffff) }, // cyan glow
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 uColor;
    varying vec2 vUv;

    void main() {
      // Always outputs emissive color, ignores lighting
      gl_FragColor = vec4(uColor, 1.0);
    }
  `,
  transparent: false,
});
    
 const uniforms = {
  uTime: { value: 0 },
  uSpeed: { value: 4.0 },
  uFrequency: { value: 80.0 },
  uDistortion: { value: .0 }
};

// Material
const materialLine = new THREE.ShaderMaterial({
  uniforms,
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    uniform float uSpeed;
    uniform float uFrequency;
    uniform float uDistortion;
    varying vec2 vUv;

    void main() {
      // Animate UVs along X axis
      float x = vUv.y * uFrequency + uTime * uSpeed + cos(vUv.x*00.0*uTime);

      // Distort Y with a sine wave for wavy streaks
      float y = vUv.x + sin(vUv.y * 5.0 + uTime) * uDistortion;

      // Grid lines by taking fractional part
      float lineX = abs(sin(x * .31415 * 2.));
      float lineY = abs(sin(y * 314.15 * 4.));

      // Combine X streaks and faint Y lines for grid effect
      float streaks = smoothstep(0.5, 1.0, lineX);
      float grid    = smoothstep(0.1, .1, lineY);

      // Mix streaks (bright laser lines) and faint grid
      vec3 color = mix(vec3(0, 0., 0.0), vec3(1.0, 1.0, 1.0), streaks);
      color -= grid * .99;

      gl_FragColor = vec4(color, 1.0);
    }
  `,
  side: THREE.DoubleSide,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});
init();
animate();
//THREE.RectAreaLightUniformsLib.init();
    
    

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000);
  

  camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.copy(originalPosition);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.physicallyCorrectLights = true;
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.body.appendChild(renderer.domElement);

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.copy(originalTarget);
  controls.update();

  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
  
  

  // Lights
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(10, 10, 10);
  //light.castShadow = true;
  light.shadow.mapSize.width = 256;
  light.shadow.mapSize.height = 256;
  //scene.add(light);

  const ambient = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambient);

  const pointLight1 = new THREE.PointLight(0xffffff, 100, 100);
  pointLight1.position.set(0, 50, -3);
  pointLight1.shadow.mapSize.width = 4096;
  pointLight1.shadow.mapSize.height = 4096;
  pointLight1.castShadow = true;
  scene.add(pointLight1);
  
  const rectLight = new THREE.RectAreaLight( 0xffffff, 00,  10, 10 );
  rectLight.castShadow=true;
rectLight.position.set( 0, 100, 0 );
rectLight.lookAt( 0, 0, 0 );
  //scene.add( rectLight )
  
  
  const geometry1 = new THREE.PlaneGeometry(10, 2, 1, 1);
   


  // Floor
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(600, 600),
    new THREE.MeshStandardMaterial({ color: 0x111111 })
  );
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);

  const roof = new THREE.Mesh(
    new THREE.CylinderGeometry(40, 40,1,64),
    new THREE.MeshStandardMaterial({ color: 0xcccccc })
  );
  roof.rotation.x = 0;//-Math.PI / 2;
  roof.position.y=50;
  roof.material = emissiveMaterial;
  scene.add(roof);
  // Podiums
  const colors = [0xff0000,0x00ff00,0x0000ff,0xffff00,0xff00ff,0x00ffff,0xff8800,0x8800ff];
  for (let i = 0; i < 0; i++) {
    const podium = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshStandardMaterial({ color: colors[i] })
    );
    let x, z, distance;
    do {
      const angle = Math.random() * Math.PI * 2;
      distance = 3 + Math.random() * 8;
      x = Math.cos(angle) * distance;
      z = Math.sin(angle) * distance;
    } while (distance < 2);
    podium.position.set(x, 0.5, z);
    podium.rotation.y = Math.random() * Math.PI * 2;
    podium.castShadow=true;
    scene.add(podium);
    podiums.push(podium);
  }

  // Load GLTF (keep original materials!)
  const loader = new THREE.GLTFLoader();
loader.load(
  //'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb'
  'https://static.wixstatic.com/3d/a2e228_247044ddb9ca45c4aa950ba98b4e2993.glb',
  function (gltf) {
    const model = gltf.scene;
    model.position.set(0, 0, -3);
    model.scale.setScalar(2);

    model.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = false;
        child.receiveShadow = false;

        // 🔄 Replace material with a lit one
        const oldMat = child.material;
        child.material = new THREE.MeshStandardMaterial({
          map: oldMat.map || null,            // keep texture if it exists
          color: oldMat.color || new THREE.Color(0xffffff),
          metalness: 0.3,                     // tweak as needed
          roughness: 0.7,
        });
        child.material = materialLine;
      }
    });

    scene.add(model);
  }
);
  
  // Load GLTF (keep original materials!)
  const loader2 = new THREE.GLTFLoader();
loader2.load(
  //'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb'
  'https://static.wixstatic.com/3d/a2e228_1e44de663be545ab82f13cf1f8e09a30.glb',
  function (gltf) {
    const model = gltf.scene;
    model.position.set(0, 0, -3);
    model.scale.setScalar(2);

    model.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;

        // 🔄 Replace material with a lit one
        const oldMat = child.material;
        child.material = new THREE.MeshStandardMaterial({
          map: oldMat.map || null,            // keep texture if it exists
          color: oldMat.color || new THREE.Color(0xffffff),
          metalness: 0.3,                     // tweak as needed
          roughness: 0.7,
        });
        
      }
    });

    scene.add(model);
  }
);
  
  addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb',
  position: new THREE.Vector3(0, 0, -14),
  rotation: Math.PI / 4,
  scale: .1,
  plinthHeight: 1,
  plinthRadius: .6,
    objectOffsetHeight: .7
});
    addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb',
  position: new THREE.Vector3(10, 0, 10),
  rotation: Math.PI / 4,
  scale: .1,
  plinthHeight: 1,
  plinthRadius: .6,
    objectOffsetHeight: .7
});

    addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb',
  position: new THREE.Vector3(14, 0, 0),
  rotation: Math.PI / 8,
  scale: .1,
  plinthHeight: 1,
  plinthRadius: .6,
    objectOffsetHeight: .7
});

  
  
     addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb',
  position: new THREE.Vector3(-10, 0, -10),
  rotation: Math.PI / 8,
  scale: .1,
  plinthHeight: 1,
  plinthRadius: .6,
    objectOffsetHeight: .7
}); 
  
  
      addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb',
  position: new THREE.Vector3(10, 0, -10),
  rotation: Math.PI / 8,
  scale: .1,
  plinthHeight: 1,
  plinthRadius: .6,
    objectOffsetHeight: .7
});
  
  
  
  
  
  // 3. Mesh
const streakMesh = new THREE.Mesh(geometry1, materialLine);
streakMesh.position.set(0, 2, 0);
scene.add(streakMesh);





      window.addEventListener('click', onMouseClick);
      window.addEventListener('resize', onWindowResize);

      document.getElementById('exitBtn').addEventListener('click', () => {
        zooming = false;
        targetPosition = null;
        targetLookAt = null;
        if (savedCameraPosition && savedCameraTarget) {
          camera.position.copy(savedCameraPosition);
          controls.target.copy(savedCameraTarget);
        } else {
          camera.position.copy(originalPosition);
          controls.target.copy(originalTarget);
        }
        controls.enabled = true;
        controls.update();
        document.getElementById('exitBtn').style.display = 'none';
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseClick(event) {
      if (!controls.enabled) return;
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(podiums);
      if (intersects.length > 0) {
        savedCameraPosition = camera.position.clone();
        savedCameraTarget = controls.target.clone();
        const podium = intersects[0].object;
        const podiumPos = podium.position.clone();
        const frontDirection = new THREE.Vector3(0, 0, 1);
        frontDirection.applyEuler(podium.rotation);
        const cameraOffset = frontDirection.multiplyScalar(3);
        targetPosition = podiumPos.clone().add(cameraOffset);
        targetPosition.y = podiumPos.y + 1.8;
        targetLookAt = podiumPos.clone();
        targetLookAt.y += 1.3;
        zooming = true;
        controls.enabled = false;
        document.getElementById('exitBtn').style.display = 'block';
      }
    }
    
    function addModelOnPlinth({
      url,             // GLTF url
      position,        // THREE.Vector3
      rotation = 0,    // y-axis rotation in radians
      scale = 1,       // uniform scale
      plinthHeight = 1,
      plinthRadius = 0.7,
      objectOffsetHeight=0.5
    }) {
      const group = new THREE.Group();
      group.position.copy(position);
      group.rotation.y = rotation;

      // Cylinder plinth
      const plinth = new THREE.Mesh(
        new THREE.CylinderGeometry(plinthRadius, plinthRadius, plinthHeight, 32),
        new THREE.MeshStandardMaterial({ color: 0x888888 })
      );
      plinth.position.y = plinthHeight / 2; // lift so bottom sits at ground
      plinth.castShadow = true;
      plinth.receiveShadow = true;
      group.add(plinth);

      // Load model
      const loader = new THREE.GLTFLoader();
      loader.load(url, (gltf) => {
        const model = gltf.scene;
        model.scale.setScalar(scale);

        // place on top of plinth
        model.position.y = plinthHeight+objectOffsetHeight;

        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;

            // Convert unlit materials if needed
            if (child.material.type === "MeshBasicMaterial") {
              child.material = new THREE.MeshStandardMaterial({
                map: child.material.map || null,
                color: child.material.color || new THREE.Color(0xffffff),
                metalness: 0.3,
                roughness: 0.7
              });
            }
          }
        });

        group.add(model);
      });

      scene.add(group);

      // Add click-to-move
      //group.userData.isClickable = true;
      
      const podium = new THREE.Mesh(
          new THREE.BoxGeometry(2, 2, 2),
         
        );
        let x, z, distance;
        do {
          const angle = Math.random() * Math.PI * 2;
          distance = 3 + Math.random() * 8;
          x = Math.cos(angle) * distance;
          z = Math.sin(angle) * distance;
        } while (distance < 2);
        podium.position.set(position.x,position.y,position.z);
        podium.rotation.y = rotation;
        scene.add(podium);
        podiums.push(podium);
      
      
      //podiums.push(group); // store for raycasting

      return group;
    }
    
    // 4. Animate
function animateStreaks(delta) {
  materialLine.uniforms.uTime.value += delta;
}


    function animate() {
      requestAnimationFrame(animate);
      if (zooming && targetPosition && targetLookAt) {
        camera.position.lerp(targetPosition, zoomSpeed);
        controls.target.lerp(targetLookAt, zoomSpeed);
        controls.update();
        if (camera.position.distanceTo(targetPosition) < 0.05) {
          zooming = false;
        }
      }
      const delta = clock.getDelta();
      animateStreaks(delta);
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
