
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Three.js Gallery Teleport with Voiceover</title>
  <style>
    html, body { margin: 0; overflow: hidden; height: 100%; font-family: "Helvetica", Arial, sans-serif; }
    #exitBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      padding: 10px 15px;
      background: rgba(0,0,0,0.7);
      color: white;
      border: none;
      font-size: 16px;
      cursor: pointer;
      display: none;
    }
    #subtitleBox {
      position: absolute;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.6);
      color: #fff;
      padding: 10px 20px;
      border-radius: 0px;
      font-size: 18px;
      text-align: center;
      max-width: 90%;
      width:70%;
      z-index: 15;
      display: none;
      font-size:36px;
    }
    #audioControls {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 0px;
      display: flex;
      align-items: center;
      gap: 10px;
      z-index: 20;
      width: calc(100% - 40px);
    }
    #seekBar {
      width: 100%;
    }
    #startBtn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-size: 24px;
      background: rgba(0,0,0,0.8);
      color: white;
      border: none;
      border-radius: 0px;
      cursor: pointer;
      z-index: 100;
    }
    #instructions {
      display: none;
      position: absolute;
      top: 10px;
      left:10px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 0px;
      align-items: center;
      gap: 10px;
      z-index: 20;
      color:white;
    }
    button {
      background: #444;
      color: white;
      border: none;
      padding: 6px 12px;
      cursor: pointer;
      border-radius: 0px;
    }
    button:hover {
      background: #666;
    }
  </style>
</head>
<body>
  <button id="startBtn">▶ Start Experience<p style="font-size:.5em;">WARNING: This content contains flashing images or patterns that may trigger seizures in individuals with photosensitive epilepsy or other light-sensitive conditions. Viewer discretion is advised. </p></button>
  <button id="exitBtn">Exit</button>
  <div id="subtitleBox"></div>

  <!-- Custom audio controls -->
  <div id="audioControls">
    
    <button id="playPauseBtn">▶ Play</button>
    <button id="muteBtn">Mute</button>
    <input type="range" id="seekBar" value="0" min="0" max="100" step="0.1">
  </div>

  <div id="instructions">Click on 3d</div>
  <audio id="voiceover" preload="auto"></audio>
  
  

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
  
<!-- Post-processing -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/FilmPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/BokehShader.js"></script>
    

  <script>
    /* -------------------------------
       🎤 AUDIO + SUBTITLES SYSTEM
    ------------------------------- */
    const audioElement = document.getElementById("voiceover");
    const subtitleBox = document.getElementById("subtitleBox");
    const playPauseBtn = document.getElementById("playPauseBtn");
    const muteBtn = document.getElementById("muteBtn");
    const seekBar = document.getElementById("seekBar");

    // 👉 Swap audio file here
    audioElement.src = "https://static.wixstatic.com/mp3/a2e228_383cc18955d047a2b9df8ec788c84f6e.mp3"; // Replace with your file

    // 👉 Subtitles format: { start, end, text }
    const subtitles = [
  { start: 0.179, end: 2.099, text: "The School of Media and Communication at" },
  { start: 2.119, end: 4.359, text: "the London College of Fashion is a vibrant" },
  { start: 4.38, end: 7.099, text: "and dedicated community. We believe in" },
  { start: 7.119, end: 8.999, text: "shaping the future of fashion media," },
  { start: 9.26, end: 11.56, text: "communication, and design for performance." },
  { start: 12.159, end: 14.18, text: "The three programs span a wide range of" },
  { start: 14.239, end: 17.139, text: "disciplines from fashion film photography," },
  { start: 17.5, end: 19.62, text: "creative direction, fashion media and" },
  { start: 19.699, end: 22.22, text: "criticism, fashion curation, costume" },
  { start: 22.279, end: 25.439, text: "design, hair and makeup, and prosthetics" },
  { start: 25.459, end: 27.339, text: "for performance amongst many others." },
  { start: 28.219, end: 30.38, text: "But it is this interrelationship and the" },
  { start: 30.439, end: 32.04, text: "potentials at the edges of those" },
  { start: 32.099, end: 34.559, text: "disciplines that really enable us to move" },
  { start: 34.639, end: 37.54, text: "forward and to change our industries. As a" },
  { start: 37.599, end: 39.54, text: "school, we champion the values of" },
  { start: 39.599, end: 41.74, text: "collaboration, openness, and" },
  { start: 41.819, end: 44.379, text: "communication. This enables us to build" },
  { start: 44.399, end: 46.279, text: "opportunities between communities and" },
  { start: 46.299, end: 47.02, text: "disciplines." },
  { start: 47.739, end: 50.279, text: "We cultivate rich networks and connections" },
  { start: 50.299, end: 52.679, text: "with industry practitioners to pioneer" },
  { start: 52.759, end: 55.299, text: "new ways of collaborating based on shared" },
  { start: 55.34, end: 57.9, text: "values of co-curation and knowledge" },
  { start: 57.959, end: 58.58, text: "exchange." },
  { start: 59.479, end: 61.579, text: "Our students gain access to our research" },
  { start: 61.639, end: 63.639, text: "centers which include the Digital" },
  { start: 63.719, end: 66.04, text: "Anthropology Lab, the Center for Fashion" },
  { start: 66.119, end: 68.819, text: "Curation, and a whole range of hubs and" },
  { start: 68.879, end: 70.999, text: "networks that really do enrich their" },
  { start: 71.059, end: 72.359, text: "learning and experience." },
  { start: 73.059, end: 75.459, text: "Core to our approach is an understanding" },
  { start: 75.5, end: 77.939, text: "that the body is a creative site, and this" },
  { start: 78.0, end: 79.659, text: "connects all of our disciplines." },
  { start: 80.279, end: 82.239, text: "We also share values of engagement," },
  { start: 82.58, end: 85.459, text: "innovation, and activism which continue to" },
  { start: 85.479, end: 87.939, text: "enable us to move forward and to think in" },
  { start: 88.0, end: 88.659, text: "new ways." },
  { start: 89.439, end: 91.239, text: "Our students and staff work across" },
  { start: 91.299, end: 93.519, text: "disciplines and platforms, and we seek to" },
  { start: 93.54, end: 96.199, text: "create meaningful experiences and generate" },
  { start: 96.22, end: 98.399, text: "creative solutions to critical issues of" },
  { start: 98.4, end: 98.999, text: "our time." },
  { start: 100.099, end: 102.18, text: "Fashion for us is much more than just" },
  { start: 102.239, end: 104.519, text: "clothes or images. It's actually about" },
  { start: 104.54, end: 106.779, text: "experiences, and it has the capability to" },
  { start: 106.839, end: 108.46, text: "change lives. Thank you." }
]
;

    // Play/Pause toggle
    playPauseBtn.addEventListener("click", () => {
      if (audioElement.paused) {
        audioElement.play();
        playPauseBtn.textContent = "⏸ Pause";
      } else {
        audioElement.pause();
        playPauseBtn.textContent = "▶ Play";
      }
    });

    // Mute toggle
    muteBtn.addEventListener("click", () => {
      audioElement.muted = !audioElement.muted;
      muteBtn.textContent = audioElement.muted ? "🔊" : "Mute";
    });

    // Update seek bar as audio plays
    audioElement.addEventListener("timeupdate", () => {
      seekBar.value = (audioElement.currentTime / audioElement.duration) * 100;

      // Subtitles sync
      const currentTime = audioElement.currentTime;
      const currentSubtitle = subtitles.find(s => currentTime >= s.start && currentTime <= s.end);
      if (currentSubtitle) {
        subtitleBox.style.display = "block";
        subtitleBox.textContent = currentSubtitle.text;
      } else {
        subtitleBox.style.display = "none";
      }
    });

    // Seeking
    seekBar.addEventListener("input", () => {
      audioElement.currentTime = (seekBar.value / 100) * audioElement.duration;
    });

    // Reset play button when audio ends
    audioElement.addEventListener("ended", () => {
      playPauseBtn.textContent = "▶ Play";
      subtitleBox.style.display = "none";
      seekBar.value = 0;
    });
    
    const startBtn = document.getElementById("startBtn");

// ✅ Disable auto-rotate until user clicks
//controls.autoRotate = false;
//controls.update();

// ✅ Hide audio controls until started
document.getElementById("audioControls").style.display = "none";
document.getElementById("instructions").style.display = "none";
    /*
startBtn.addEventListener("click", () => {
  // Start spinning
  //controls.autoRotate = true;

  // Start audio (must be triggered by user gesture)
  audioElement.play();
  playPauseBtn.textContent = "⏸ Pause";

  // Show audio controls
  document.getElementById("audioControls").style.display = "flex";

  // Hide start button
  startBtn.style.display = "none";
});
*/
    startBtn.addEventListener("click", async () => {
  // Resume context first
  if (audioCtx.state === "suspended") {
    await audioCtx.resume();
    console.log("AudioContext resumed");
  }

  // Unmute before play
  audioElement.muted = false;

  // Play audio
  try {
    await audioElement.play();
    playPauseBtn.textContent = "⏸ Pause";
  } catch (err) {
    console.error("Play failed:", err);
  }

  // Show audio controls
  document.getElementById("audioControls").style.display = "flex";
document.getElementById("instructions").style.display = "flex";
  // Hide start button
  startBtn.style.display = "none";
});

    //this is needed for audio reactive to work
    audioElement.crossOrigin = "anonymous";
    
    //audio sync

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const audioSource = audioCtx.createMediaElementSource(audioElement);
const analyser = audioCtx.createAnalyser();
analyser.fftSize = 256;
const dataArray = new Uint8Array(analyser.frequencyBinCount);

// Connect nodes
audioSource.connect(analyser);
analyser.connect(audioCtx.destination);



    
    /* -------------------------------
       🎨 YOUR EXISTING THREE.JS CODE
    ------------------------------- */
let scene, camera, renderer, controls, composer;
let raycaster, mouse;
let targetPosition = null;
let targetLookAt = null;
let zooming = false;
const zoomSpeed = 0.05;
const podiums = [];

let savedCameraPosition = null;
let savedCameraTarget = null;

const originalPosition = new THREE.Vector3(0, 2, 8);
const originalTarget = new THREE.Vector3(0, 2, 0);
const clock = new THREE.Clock();
    
const emissiveMaterial = new THREE.ShaderMaterial({
  uniforms: {
    uColor: { value: new THREE.Color(0xffffff) }, // cyan glow
  },
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform vec3 uColor;
    varying vec2 vUv;

    void main() {
      // Always outputs emissive color, ignores lighting
      gl_FragColor = vec4(uColor, 1.0);
    }
  `,
  transparent: false,
});
    
 const uniforms = {
  uTime: { value: 0 },
  uSpeed: { value: 1.5 },
  uFrequency: { value: 80.0 },
  uDistortion: { value: -0.003 },
   uAudio: { value: 0.0 } // audio-reactive uniform
};

// Material
const materialLine = new THREE.ShaderMaterial({
  uniforms,
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    uniform float uSpeed;
    uniform float uFrequency;
    uniform float uDistortion;
    uniform float uAudio;
    varying vec2 vUv;

    void main() {
      // Animate UVs along X axis
      float x = vUv.y * uFrequency + uTime * uSpeed + cos(vUv.x*0.0+uTime);

      // Distort Y with a sine wave for wavy streaks
      float y = vUv.x + sin(vUv.y * 5.0 + uTime) * uDistortion ;

      // Grid lines by taking fractional part
      float lineX = abs(sin(x * .31415 * 2.0));
      float lineY = abs(sin(y * 314.15 * 6.0 ));

      // Combine X streaks and faint Y lines for grid effect
      float streaks = smoothstep(0.5, 1.0, lineX);
      float grid    = smoothstep(0.1, .2, lineY);

      // Mix streaks (bright laser lines) and faint grid
      vec3 color = mix(vec3(.0, 0., 0.05), vec3(0, 0.3, .8), streaks);
      color -= grid * .99;

      gl_FragColor = vec4(color, 1.0);
    }
  `,
  side: THREE.DoubleSide,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});
    const uniformsA = {
  uTime: { value: 0 },
  uSpeed: { value: 1.5 },
  uFrequency: { value: 40.0 },
  uDistortion: { value: -0.003 },
   uAudio: { value: 0.0 } // audio-reactive uniform
};

// Material
const materialLineA = new THREE.ShaderMaterial({
  uniforms:uniformsA,
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    uniform float uSpeed;
    uniform float uFrequency;
    uniform float uDistortion;
    uniform float uAudio;
    varying vec2 vUv;

    void main() {
      // Animate UVs along X axis
      float x = vUv.y * uFrequency + uTime * uSpeed  + cos(vUv.x*(uAudio*100.0)*2.0+uTime)*uAudio*20.0;

      // Distort Y with a sine wave for wavy streaks
      float y = vUv.x + sin(vUv.y * 5.0 + uTime) * uDistortion ;

      // Grid lines by taking fractional part
      float lineX = abs(sin(x * .31415 * 2.0));
      float lineY = abs(sin(y * 314.15 * 4.0 ));

      // Combine X streaks and faint Y lines for grid effect
      float streaks = smoothstep(.9, 1.0, lineX);
      float grid    = smoothstep(0.5, .9, lineY);

      // Mix streaks (bright laser lines) and faint grid
      vec3 color = mix(vec3(0, 0., 0.0), vec3(1.0, 1.0, 1.0), streaks);
      color -= grid * .99;

      gl_FragColor = vec4(color, 1.0);
    }
  `,
  side: THREE.DoubleSide,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});
     const uniformsOuter = {
  uTime: { value: 0 },
  uSpeed: { value: 2.0 },
  uFrequency: { value: 1000.0 },
  uDistortion: { value: .002 }
};

const materialLineOuter = new THREE.ShaderMaterial({
  uniforms: uniformsOuter, // <-- pass uniforms here
  vertexShader: `
    varying vec2 vUv;
    void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `,
  fragmentShader: `
    uniform float uTime;
    uniform float uSpeed;
    uniform float uFrequency;
    uniform float uDistortion;
    varying vec2 vUv;

    void main() {
      // Animate UVs along X axis
      float x = vUv.y * uFrequency + uTime * uSpeed + cos(vUv.x*0.0*uTime);

      // Distort Y with a sine wave for wavy streaks
      float y = vUv.x + sin(vUv.y * 5.0 + uTime) * uDistortion;

      // Grid lines by taking fractional part
      float lineX = abs(sin(x * 0.31415 * 4.0));
      float lineY = abs(sin(y * 314.15 * 8.0));

      // Combine X streaks and faint Y lines
      float streaks = smoothstep(0.5, 1.0, lineX);
      float grid    = smoothstep(0.1, 0.1, lineY);

      // Mix streaks and faint grid
      vec3 color = mix(vec3(0.0), vec3(1.0), streaks);
      color -= grid * 0.99;

      gl_FragColor = vec4(color, 1.0);
    }
  `,
  side: THREE.DoubleSide,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

init();
animate();
//THREE.RectAreaLightUniformsLib.init();
    
    

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000);
  

  camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.copy(originalPosition);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.physicallyCorrectLights = true;
  renderer.outputEncoding = THREE.sRGBEncoding;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  document.body.appendChild(renderer.domElement);
  

// POST-PROCESSING SETUP
       composer = new THREE.EffectComposer(renderer);
  composer.setSize(window.innerWidth, window.innerHeight);
  // render pass (base scene)
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);
  
  // bloom pass
const bloomPass = new THREE.UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    .2,  // strength
    0.1,  // radius
    0.85  // threshold
);
composer.addPass(bloomPass);
  




  
  //controls

  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.copy(originalTarget);
  
  // ✅ Enable auto-rotate
  controls.autoRotate = true;         // turn on auto-rotation
  controls.autoRotateSpeed = .4;     // adjust rotation speed (positive = clockwise, negative = counter-clockwise)

  // ✅ Lock zoom level
  //const lockDistance = camera.position.distanceTo(originalTarget);
  //controls.minDistance = lockDistance;
  //controls.maxDistance = lockDistance;

  // disable zooming via scroll
  controls.enableZoom = false;
  
  controls.update();
  
  

  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();
  
  

  // Lights
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(10, 10, 10);
  //light.castShadow = true;
  light.shadow.mapSize.width = 256;
  light.shadow.mapSize.height = 256;
  //scene.add(light);

  const ambient = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambient);

  const pointLight1 = new THREE.PointLight(0xffffff, 100, 100);
  pointLight1.position.set(0, 50, -3);
  pointLight1.shadow.mapSize.width = 4096;
  pointLight1.shadow.mapSize.height = 4096;
  pointLight1.castShadow = true;
  scene.add(pointLight1);
  
  const rectLight = new THREE.RectAreaLight( 0xffffff, 0,  10, 10 );
  rectLight.castShadow=true;
rectLight.position.set( 0, 100, 0 );
rectLight.lookAt( 0, 0, 0 );
  //scene.add( rectLight )
  
  

   


  // Floor
  const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(600, 600),
    new THREE.MeshStandardMaterial({ color: 0x070707 })
  );
  floor.rotation.x = -Math.PI / 2;
  floor.receiveShadow = true;
  scene.add(floor);
  
  //outersphere
  const outerSphere = new THREE.Mesh(
    new THREE.SphereGeometry( 100, 32, 16 )
  );
  outerSphere.material=materialLineOuter;
  outerSphere.position.y=1;
  
  scene.add(outerSphere);

  const roof = new THREE.Mesh(
    new THREE.CylinderGeometry(40, 40,1,64),
    new THREE.MeshStandardMaterial({ color: 0xcccccc })
  );
  roof.rotation.x = 0;//-Math.PI / 2;
  roof.position.y=50;
  roof.material = emissiveMaterial;
  scene.add(roof);
  // Podiums
  const colors = [0xff0000,0x00ff00,0x0000ff,0xffff00,0xff00ff,0x00ffff,0xff8800,0x8800ff];
  for (let i = 0; i < 0; i++) {
    const podium = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshStandardMaterial({ color: colors[i] })
    );
    let x, z, distance;
    do {
      const angle = Math.random() * Math.PI * 2;
      distance = 3 + Math.random() * 8;
      x = Math.cos(angle) * distance;
      z = Math.sin(angle) * distance;
    } while (distance < 2);
    podium.position.set(x, 0.5, z);
    podium.rotation.y = Math.random() * Math.PI * 2;
    podium.castShadow=true;
    scene.add(podium);
    podiums.push(podium);
  }

  // Load GLTF (keep original materials!)
  const loader = new THREE.GLTFLoader();
loader.load(
  //'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb'
  'https://static.wixstatic.com/3d/a2e228_247044ddb9ca45c4aa950ba98b4e2993.glb',
  function (gltf) {
    const model = gltf.scene;
    model.position.set(0, 0, -3);
    model.scale.setScalar(2);

    model.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = false;
        child.receiveShadow = false;

        // 🔄 Replace material with a lit one
        const oldMat = child.material;
        child.material = new THREE.MeshStandardMaterial({
          map: oldMat.map || null,            // keep texture if it exists
          color: oldMat.color || new THREE.Color(0xffffff),
          metalness: 0.3,                     // tweak as needed
          roughness: 0.7,
        });
        child.material = materialLine;
      }
    });

    scene.add(model);
  }
);
  
  // Load GLTF (keep original materials!)
  const loader2 = new THREE.GLTFLoader();
loader2.load(
  //'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb'
  'https://static.wixstatic.com/3d/a2e228_25896596c8f74a9fbadf063c00e6f466.glb',
  function (gltf) {
    const model = gltf.scene;
    model.position.set(0, 0, -3);
    model.scale.setScalar(2);

    model.traverse((child) => {
      if (child.isMesh) {
        child.castShadow = true;
        child.receiveShadow = true;

        // 🔄 Replace material with a lit one
        const oldMat = child.material;
        child.material = new THREE.MeshStandardMaterial({
          map: oldMat.map || null,            // keep texture if it exists
          color: oldMat.color || new THREE.Color(0xffffff),
          metalness: 0.3,                     // tweak as needed
          roughness: 0.7,
        });
        
      }
    });

    scene.add(model);
  }
);
  
  //3d models
  
  //first costume scan
  addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_2b57df5830ae4be7b45a9e5b0439b05e.glb',
  position: new THREE.Vector3(0, 0, -14),
  rotation: Math.PI *2,
  scale: .25,
  plinthHeight: 1,
  plinthRadius: .8,
    objectOffsetHeight:0,
    objectOffsetRotation: 0.5
});
    addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_2b57df5830ae4be7b45a9e5b0439b05e.glb',
  position: new THREE.Vector3(10, 0, 10),
  rotation: Math.PI *1.25,
  scale: .25,
  plinthHeight: 1,
  plinthRadius: .8,
    objectOffsetHeight: 0,
      objectOffsetRotation: 0.5
});

    addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb',
  position: new THREE.Vector3(14, 0, 0),
  rotation: Math.PI / 8,
  scale: .1,
  plinthHeight: 1,
  plinthRadius: .6,
    objectOffsetHeight: .7
});

  
  
     addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb',
  position: new THREE.Vector3(-10, 0, -10),
  rotation: Math.PI / 8,
  scale: .1,
  plinthHeight: 1,
  plinthRadius: .6,
    objectOffsetHeight: .7,
       objectOffsetRotation: 0
}); 
  
  
      addModelOnPlinth({
  url: 'https://static.wixstatic.com/3d/a2e228_3826155be906420b942cb6cb95aeea92.glb',
  position: new THREE.Vector3(10, 0, -10),
  rotation: Math.PI / 8,
  scale: .1,
  plinthHeight: 1,
  plinthRadius: .6,
    objectOffsetHeight: .7
});
  
  // Place a 16:9 screen at (0,2,-5), rotated slightly
addScreen({
  url: "https://video.wixstatic.com/video/25b4fa_7e131bb1b6774460a81ea773e3b54edc/1080p/mp4/file.mp4",
  width: 25,
  height: 10,
  position: [30, 16,-5],
  rotation: [0, Math.PI*1.50, 0]
});
  
  addScreen({
  url: "https://video.wixstatic.com/video/25b4fa_7e131bb1b6774460a81ea773e3b54edc/1080p/mp4/file.mp4",
  width: 25,
  height: 10,
  position: [45, 8,10],
  rotation: [0, Math.PI*1.37, 0]
});
  
  addScreen({
  url: "https://video.wixstatic.com/video/25b4fa_7e131bb1b6774460a81ea773e3b54edc/1080p/mp4/file.mp4",
  width: 25,
  height: 15,
  position: [-30, 24,0],
  rotation: [0, Math.PI*0.50, 0]
});
  //behind screen
  addScreen({
  url: "https://video.wixstatic.com/video/25b4fa_5727856c53404310908a3443cba08b92/1080p/mp4/file.mp4",
  width: 12,
  height: 6.75,
  position: [0, 6,11],
  rotation: [0, Math.PI*1, 0]
});
  //long forward screen
    addScreen({
  url: "https://video.wixstatic.com/video/25b4fa_7e131bb1b6774460a81ea773e3b54edc/1080p/mp4/file.mp4",
  width: 12,
  height: 20,
  position: [0, 20,-31],
  rotation: [0, Math.PI*2, 0]
});
  
    //behind screen far
  addScreen({
  url: "https://video.wixstatic.com/video/25b4fa_5727856c53404310908a3443cba08b92/1080p/mp4/file.mp4",
  width: 12,
  height: 6.75,
  position: [-5, 24,37],
  rotation: [0, Math.PI*.9, 0]
});

  
    // 3. Audio Mesh
    const geometry1 = new THREE.SphereGeometry(1.2, 1 , 1);


const streakMesh = new THREE.Mesh(geometry1, materialLineA);
 
streakMesh.position.set(0, 1.5, 0);
scene.add(streakMesh);
   //streakMesh.rotation.x = Math.PI / 4; 
//streakMesh.rotation.y = Math.PI / 4; 



      window.addEventListener('click', onMouseClick);
      window.addEventListener('resize', onWindowResize);

      document.getElementById('exitBtn').addEventListener('click', () => {
        zooming = false;
        targetPosition = null;
        targetLookAt = null;
        if (savedCameraPosition && savedCameraTarget) {
          camera.position.copy(savedCameraPosition);
          controls.target.copy(savedCameraTarget);
        } else {
          camera.position.copy(originalPosition);
          controls.target.copy(originalTarget);
        }
        controls.enabled = true;
        controls.update();
        document.getElementById('exitBtn').style.display = 'none';
      });
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    }

    function onMouseClick(event) {
      if (!controls.enabled) return;
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(podiums);
      if (intersects.length > 0) {
        savedCameraPosition = camera.position.clone();
        savedCameraTarget = controls.target.clone();
        const podium = intersects[0].object;
        const podiumPos = podium.position.clone();
        const frontDirection = new THREE.Vector3(0, 0, 1);
        frontDirection.applyEuler(podium.rotation);
        const cameraOffset = frontDirection.multiplyScalar(3);
        targetPosition = podiumPos.clone().add(cameraOffset);
        targetPosition.y = podiumPos.y + .5;
        targetLookAt = podiumPos.clone();
        targetLookAt.y += 0;
        zooming = true;
        controls.enabled = false;
        document.getElementById('exitBtn').style.display = 'block';
      }
    }
    
    function addScreen({ url, width = 4, height = 2.25, position = [0, 0, 0], rotation = [0, 0, 0] }) {
  // 1. Create video element
  const video = document.createElement('video');
  video.src = url;
  video.crossOrigin = "anonymous";
  video.loop = true;
  video.muted = true; // autoplay requires muted in browsers
  video.playsInline = true;
  video.autoplay = true;
  video.play();

  // 2. Create texture from video
  const videoTexture = new THREE.VideoTexture(video);
  videoTexture.minFilter = THREE.LinearFilter;
  videoTexture.magFilter = THREE.LinearFilter;
  videoTexture.format = THREE.RGBFormat;

  // 3. Create material
  const material = new THREE.MeshBasicMaterial({
    map: videoTexture,
    side: THREE.FrontSide,
    toneMapped: false // keeps colors bright
  });

  // 4. Create plane geometry for screen
  const geometry = new THREE.PlaneGeometry(width, height);
  const screenMesh = new THREE.Mesh(geometry, material);

  // 5. Set position + rotation
  screenMesh.position.set(...position);
  screenMesh.rotation.set(...rotation);

  // 6. Add to scene
  scene.add(screenMesh);

  return screenMesh; // return so you can keep a reference if needed
}

    
    function addModelOnPlinth({
      url,             // GLTF url
      position,        // THREE.Vector3
      rotation = 0,    // y-axis rotation in radians
      scale = 1,       // uniform scale
      plinthHeight = 1,
      plinthRadius = 0.7,
      objectOffsetHeight=0.5,
      objectOffsetRotation=0
    }) {
      const group = new THREE.Group();
      group.position.copy(position);
      group.rotation.y = rotation;

      // Cylinder plinth
      const plinth = new THREE.Mesh(
        new THREE.CylinderGeometry(plinthRadius, plinthRadius, plinthHeight, 32),
        new THREE.MeshStandardMaterial({ color: 0x777777 })
      );
      plinth.position.y = plinthHeight / 2; // lift so bottom sits at ground
      plinth.castShadow = true;
      plinth.receiveShadow = true;
      group.add(plinth);

      // Load model
      const loader = new THREE.GLTFLoader();
      loader.load(url, (gltf) => {
        const model = gltf.scene;
        model.scale.setScalar(scale);

        // place on top of plinth
        model.position.y = plinthHeight+objectOffsetHeight;
        model.rotation.y=objectOffsetRotation;
        model.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;

            // Convert unlit materials if needed
            if (child.material.type === "MeshBasicMaterial") {
              child.material = new THREE.MeshStandardMaterial({
                map: child.material.map || null,
                color: child.material.color || new THREE.Color(0xffffff),
                metalness: 0.3,
                roughness: 0.7
              });
            }
          }
        });

        group.add(model);
      });

      scene.add(group);

      // Add click-to-move
      //group.userData.isClickable = true;
      
      const podium = new THREE.Mesh(
          new THREE.BoxGeometry(2, 4, 2),
         
        );
      
        let x, z, distance;
        do {
          const angle = Math.random() * Math.PI * 2;
          distance = 3 + Math.random() * 8;
          x = Math.cos(angle) * distance;
          z = Math.sin(angle) * distance;
        } while (distance < 2);
        podium.position.set(position.x,position.y+2,position.z);
        podium.rotation.y = rotation;
      podium.visible=false;
        scene.add(podium);
        podiums.push(podium);
      
      
      const pointLight1 = new THREE.PointLight(0xffffff, 50, 12);
  pointLight1.position.set(position.x,position.y+10,position.z);

  pointLight1.castShadow = false;
  scene.add(pointLight1);
      
      //podiums.push(group); // store for raycasting

      return group;
    }
    
    // 4. Animate
function animateStreaks(delta) {
  materialLine.uniforms.uTime.value += delta;
  materialLineOuter.uniforms.uTime.value += delta;
  
  //Audio reactive stuff
  // Get average frequency from analyser
  analyser.getByteFrequencyData(dataArray);

  // Compute normalized audio value (0-1)
  let sum = 0;
  for (let i = 0; i < dataArray.length; i++) {
    sum += dataArray[i];
  }
  const avg = sum / dataArray.length;
  uniformsA.uAudio.value = avg / 255; // normalized
}


    function animate() {
      requestAnimationFrame(animate);
      if (zooming && targetPosition && targetLookAt) {
        camera.position.lerp(targetPosition, zoomSpeed);
        controls.target.lerp(targetLookAt, zoomSpeed);
        controls.update();
        if (camera.position.distanceTo(targetPosition) < 0.05) {
          zooming = false;
        }
      }
      const delta = clock.getDelta();
      animateStreaks(delta);
      controls.update();
      
      
      //renderer.render(scene, camera);
      // Render with post-processing
      composer.render();
    }
  </script>
</body>
</html>
